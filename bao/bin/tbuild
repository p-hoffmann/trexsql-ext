#!/bin/bash
set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TREX_CMD="$SCRIPT_DIR/trex"

if [[ -z "$1" ]] || [[ "$1" == "." ]] || [[ "$1" =~ node_modules/@(data2evidence|trex) ]]; then
    PROJECT_PATH="$(pwd)"
else
    PROJECT_PATH="$1"
fi

if [[ ! -d "$PROJECT_PATH" ]]; then
    echo "Error: Project path does not exist: $PROJECT_PATH"
    exit 1
fi

PACKAGE_ORG="$PROJECT_PATH/package.org.json"
if [[ ! -f "$PACKAGE_ORG" ]]; then
    echo "Error: package.org.json not found at $PACKAGE_ORG"
    exit 1
fi

echo "Building TREX project: $PROJECT_PATH"

if command -v node &> /dev/null; then
    node -e "
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

const projectPath = process.argv[1];
const trexCmd = process.argv[2];
const pkg = JSON.parse(fs.readFileSync(path.join(projectPath, 'package.org.json'), 'utf8'));

function buildFunctions(functions) {
    if (!functions) return [];
    return functions.map(f => {
        if (f.function) {
            // Strip leading slash to prevent path.join from treating it as absolute
            const funcPath = f.function.replace(/^\\//, '');
            const entrypoint = path.join(projectPath, funcPath, 'index.ts');
            const output = path.join(projectPath, funcPath, 'index.eszip');

            let args = ['bundle', '-e', entrypoint, '-o', output];

            console.log('\\n=== Bundling:', f.function, '===');
            console.log('  Project path:', projectPath);
            console.log('  Function path (stripped):', funcPath);
            console.log('  Entrypoint:', entrypoint);
            console.log('  Output:', output);
            console.log('  Entrypoint exists:', fs.existsSync(entrypoint));
            console.log('  Command:', [trexCmd, ...args].join(' '));

            // Check for deno.json in function directory
            const funcDir = path.dirname(entrypoint);
            const denoJson = path.join(funcDir, 'deno.json');
            const sharedDir = path.join(projectPath, '_shared');
            const nodeModules = path.join(funcDir, 'node_modules');
            console.log('  Function dir:', funcDir);
            console.log('  deno.json exists:', fs.existsSync(denoJson));
            console.log('  _shared dir exists:', fs.existsSync(sharedDir));
            console.log('  node_modules exists:', fs.existsSync(nodeModules));

            // List contents of function dir
            try {
                const contents = fs.readdirSync(funcDir);
                console.log('  Function dir contents:', contents.join(', '));
            } catch (e) {
                console.log('  Function dir contents: ERROR -', e.message);
            }

            try {
                execSync([trexCmd, ...args].join(' '), { stdio: 'inherit' });
                f.eszip = f.function + '/index.eszip';
            } catch (err) {
                console.error('Failed to bundle:', f.function);
                process.exit(1);
            }
        }
        return f;
    });
}

if (pkg.trex && pkg.trex.functions) {
    if (pkg.trex.functions.api) {
        pkg.trex.functions.api = buildFunctions(pkg.trex.functions.api);
    }
    if (pkg.trex.functions.init) {
        pkg.trex.functions.init = buildFunctions(pkg.trex.functions.init);
    }
}

fs.writeFileSync(path.join(projectPath, 'package.json'), JSON.stringify(pkg, null, 2));
console.log('Build complete. Updated package.json');
" "$PROJECT_PATH" "$TREX_CMD"
elif command -v deno &> /dev/null; then
    deno eval "
import * as fs from 'node:fs';
import * as path from 'node:path';
import { execSync } from 'node:child_process';

const projectPath = Deno.args[0];
const trexCmd = Deno.args[1];
const pkg = JSON.parse(fs.readFileSync(path.join(projectPath, 'package.org.json'), 'utf8'));

function buildFunctions(functions: any[]) {
    if (!functions) return [];
    return functions.map(f => {
        if (f.function) {
            // Strip leading slash to prevent path.join from treating it as absolute
            const funcPath = f.function.replace(/^\\//, '');
            const entrypoint = path.join(projectPath, funcPath, 'index.ts');
            const output = path.join(projectPath, funcPath, 'index.eszip');

            let args = ['bundle', '-e', entrypoint, '-o', output];

            console.log('\\n=== Bundling:', f.function, '===');
            console.log('  Project path:', projectPath);
            console.log('  Function path (stripped):', funcPath);
            console.log('  Entrypoint:', entrypoint);
            console.log('  Output:', output);
            console.log('  Entrypoint exists:', fs.existsSync(entrypoint));
            console.log('  Command:', [trexCmd, ...args].join(' '));

            // Check for deno.json in function directory
            const funcDir = path.dirname(entrypoint);
            const denoJson = path.join(funcDir, 'deno.json');
            const sharedDir = path.join(projectPath, '_shared');
            const nodeModules = path.join(funcDir, 'node_modules');
            console.log('  Function dir:', funcDir);
            console.log('  deno.json exists:', fs.existsSync(denoJson));
            console.log('  _shared dir exists:', fs.existsSync(sharedDir));
            console.log('  node_modules exists:', fs.existsSync(nodeModules));

            // List contents of function dir
            try {
                const contents = fs.readdirSync(funcDir);
                console.log('  Function dir contents:', contents.join(', '));
            } catch (e) {
                console.log('  Function dir contents: ERROR -', e.message);
            }

            try {
                execSync([trexCmd, ...args].join(' '), { stdio: 'inherit' });
                f.eszip = f.function + '/index.eszip';
            } catch (err) {
                console.error('Failed to bundle:', f.function);
                Deno.exit(1);
            }
        }
        return f;
    });
}

if (pkg.trex && pkg.trex.functions) {
    if (pkg.trex.functions.api) {
        pkg.trex.functions.api = buildFunctions(pkg.trex.functions.api);
    }
    if (pkg.trex.functions.init) {
        pkg.trex.functions.init = buildFunctions(pkg.trex.functions.init);
    }
}

fs.writeFileSync(path.join(projectPath, 'package.json'), JSON.stringify(pkg, null, 2));
console.log('Build complete. Updated package.json');
" "$PROJECT_PATH" "$TREX_CMD"
else
    echo "Error: Node.js or Deno is required to run tbuild"
    exit 1
fi
