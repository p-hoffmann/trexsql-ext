#!/bin/bash
set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TREX_CMD="$SCRIPT_DIR/trex"

if [[ -z "$1" ]] || [[ "$1" == "." ]] || [[ "$1" =~ node_modules/@(data2evidence|trex) ]]; then
    PROJECT_PATH="$(pwd)"
else
    PROJECT_PATH="$1"
fi

if [[ ! -d "$PROJECT_PATH" ]]; then
    echo "Error: Project path does not exist: $PROJECT_PATH"
    exit 1
fi

PACKAGE_ORG="$PROJECT_PATH/package.org.json"
if [[ ! -f "$PACKAGE_ORG" ]]; then
    echo "Error: package.org.json not found at $PACKAGE_ORG"
    exit 1
fi

echo "Building TREX project: $PROJECT_PATH"

if command -v node &> /dev/null; then
    node -e "
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

const projectPath = process.argv[1];
const trexCmd = process.argv[2];
const pkg = JSON.parse(fs.readFileSync(path.join(projectPath, 'package.org.json'), 'utf8'));

function buildFunctions(functions) {
    if (!functions) return [];
    return functions.map(f => {
        if (f.function) {
            const entrypoint = path.join(projectPath, f.function, 'index.ts');
            const output = path.join(projectPath, f.function, 'index.eszip');

            let args = ['bundle', '-e', entrypoint, '-o', output];

            if (f.imports) {
                const importMap = path.join(projectPath, f.imports);
                args.push('-i', importMap);
            }

            console.log('Bundling:', f.function);
            try {
                execSync([trexCmd, ...args].join(' '), { stdio: 'inherit' });
                f.eszip = f.function + '/index.eszip';
            } catch (err) {
                console.error('Failed to bundle:', f.function);
                process.exit(1);
            }
        }
        return f;
    });
}

if (pkg.trex && pkg.trex.functions) {
    if (pkg.trex.functions.api) {
        pkg.trex.functions.api = buildFunctions(pkg.trex.functions.api);
    }
    if (pkg.trex.functions.init) {
        pkg.trex.functions.init = buildFunctions(pkg.trex.functions.init);
    }
}

fs.writeFileSync(path.join(projectPath, 'package.json'), JSON.stringify(pkg, null, 2));
console.log('Build complete. Updated package.json');
" "$PROJECT_PATH" "$TREX_CMD"
elif command -v deno &> /dev/null; then
    deno eval "
import * as fs from 'node:fs';
import * as path from 'node:path';
import { execSync } from 'node:child_process';

const projectPath = Deno.args[0];
const trexCmd = Deno.args[1];
const pkg = JSON.parse(fs.readFileSync(path.join(projectPath, 'package.org.json'), 'utf8'));

function buildFunctions(functions: any[]) {
    if (!functions) return [];
    return functions.map(f => {
        if (f.function) {
            const entrypoint = path.join(projectPath, f.function, 'index.ts');
            const output = path.join(projectPath, f.function, 'index.eszip');

            let args = ['bundle', '-e', entrypoint, '-o', output];

            if (f.imports) {
                const importMap = path.join(projectPath, f.imports);
                args.push('-i', importMap);
            }

            console.log('Bundling:', f.function);
            try {
                execSync([trexCmd, ...args].join(' '), { stdio: 'inherit' });
                f.eszip = f.function + '/index.eszip';
            } catch (err) {
                console.error('Failed to bundle:', f.function);
                Deno.exit(1);
            }
        }
        return f;
    });
}

if (pkg.trex && pkg.trex.functions) {
    if (pkg.trex.functions.api) {
        pkg.trex.functions.api = buildFunctions(pkg.trex.functions.api);
    }
    if (pkg.trex.functions.init) {
        pkg.trex.functions.init = buildFunctions(pkg.trex.functions.init);
    }
}

fs.writeFileSync(path.join(projectPath, 'package.json'), JSON.stringify(pkg, null, 2));
console.log('Build complete. Updated package.json');
" "$PROJECT_PATH" "$TREX_CMD"
else
    echo "Error: Node.js or Deno is required to run tbuild"
    exit 1
fi
