use std::collections::HashMap;

/// Static mappings for PostgreSQL to HANA transformations
pub struct StaticMappings;

impl StaticMappings {
    /// Get PostgreSQL to HANA data type mappings
    pub fn data_type_mappings() -> HashMap<String, String> {
        let mut mappings = HashMap::new();

        // Numeric types
        mappings.insert(
            "SERIAL".to_string(),
            "INTEGER GENERATED BY DEFAULT AS IDENTITY".to_string(),
        );
        mappings.insert(
            "BIGSERIAL".to_string(),
            "BIGINT GENERATED BY DEFAULT AS IDENTITY".to_string(),
        );
        mappings.insert(
            "SMALLSERIAL".to_string(),
            "SMALLINT GENERATED BY DEFAULT AS IDENTITY".to_string(),
        );

        // String types
        mappings.insert("TEXT".to_string(), "NCLOB".to_string());
        mappings.insert("VARCHAR".to_string(), "NVARCHAR".to_string());
        mappings.insert("CHAR".to_string(), "NCHAR".to_string());
        mappings.insert("CHARACTER".to_string(), "NCHAR".to_string());
        mappings.insert("CHARACTER VARYING".to_string(), "NVARCHAR".to_string());

        // JSON types
        mappings.insert("JSON".to_string(), "NCLOB".to_string());
        mappings.insert("JSONB".to_string(), "NCLOB".to_string());

        // UUID and network types
        mappings.insert("UUID".to_string(), "NVARCHAR(36)".to_string());
        mappings.insert("INET".to_string(), "NVARCHAR(45)".to_string());
        mappings.insert("CIDR".to_string(), "NVARCHAR(45)".to_string());
        mappings.insert("MACADDR".to_string(), "NVARCHAR(17)".to_string());
        mappings.insert("MACADDR8".to_string(), "NVARCHAR(23)".to_string());

        // Binary types
        mappings.insert("BYTEA".to_string(), "BLOB".to_string());

        // Date/time types
        mappings.insert("TIMESTAMPTZ".to_string(), "TIMESTAMP".to_string());
        mappings.insert(
            "TIMESTAMP WITH TIME ZONE".to_string(),
            "TIMESTAMP".to_string(),
        );
        mappings.insert("TIMETZ".to_string(), "TIME".to_string());
        mappings.insert("TIME WITH TIME ZONE".to_string(), "TIME".to_string());

        // Geometric types (convert to string representation)
        mappings.insert("POINT".to_string(), "NVARCHAR(50)".to_string());
        mappings.insert("LINE".to_string(), "NVARCHAR(100)".to_string());
        mappings.insert("LSEG".to_string(), "NVARCHAR(100)".to_string());
        mappings.insert("BOX".to_string(), "NVARCHAR(100)".to_string());
        mappings.insert("PATH".to_string(), "NCLOB".to_string());
        mappings.insert("POLYGON".to_string(), "NCLOB".to_string());
        mappings.insert("CIRCLE".to_string(), "NVARCHAR(100)".to_string());

        // Array types (convert to JSON representation)
        mappings.insert("INTEGER[]".to_string(), "NCLOB".to_string());
        mappings.insert("TEXT[]".to_string(), "NCLOB".to_string());
        mappings.insert("VARCHAR[]".to_string(), "NCLOB".to_string());

        // Range types
        mappings.insert("INT4RANGE".to_string(), "NVARCHAR(50)".to_string());
        mappings.insert("INT8RANGE".to_string(), "NVARCHAR(50)".to_string());
        mappings.insert("NUMRANGE".to_string(), "NVARCHAR(100)".to_string());
        mappings.insert("TSRANGE".to_string(), "NVARCHAR(100)".to_string());
        mappings.insert("TSTZRANGE".to_string(), "NVARCHAR(100)".to_string());
        mappings.insert("DATERANGE".to_string(), "NVARCHAR(50)".to_string());

        mappings
    }

    /// Get PostgreSQL to HANA function mappings
    pub fn function_mappings() -> HashMap<String, String> {
        let mut mappings = HashMap::new();

        // Date/time functions
        // NOW() is supported natively in HANA, no transformation needed
        mappings.insert(
            "CURRENT_TIMESTAMP()".to_string(),
            "CURRENT_TIMESTAMP".to_string(),
        );
        mappings.insert("CURRENT_TIME()".to_string(), "CURRENT_TIME".to_string());
        mappings.insert("CURRENT_DATE()".to_string(), "CURRENT_DATE".to_string());
        mappings.insert(
            "LOCALTIMESTAMP".to_string(),
            "CURRENT_TIMESTAMP".to_string(),
        );
        mappings.insert("LOCALTIME".to_string(), "CURRENT_TIME".to_string());

        // String functions
        mappings.insert("RANDOM".to_string(), "RAND".to_string());
        mappings.insert("POSITION".to_string(), "LOCATE".to_string());
        mappings.insert("STRPOS".to_string(), "LOCATE".to_string());
        mappings.insert("CHR".to_string(), "CHAR".to_string());
        mappings.insert("ASCII".to_string(), "ASCII".to_string());
        mappings.insert("MD5".to_string(), "HASH_MD5".to_string());

        // Math functions
        mappings.insert("POWER".to_string(), "POWER".to_string());
        mappings.insert("POW".to_string(), "POWER".to_string());
        mappings.insert("SQRT".to_string(), "SQRT".to_string());
        mappings.insert("CBRT".to_string(), "POWER(?, 1.0/3.0)".to_string()); // Cube root
        mappings.insert("EXP".to_string(), "EXP".to_string());
        mappings.insert("LN".to_string(), "LN".to_string());
        mappings.insert("LOG".to_string(), "LOG".to_string());
        mappings.insert("LOG10".to_string(), "LOG".to_string());
        mappings.insert("PI".to_string(), "PI".to_string());
        mappings.insert("RADIANS".to_string(), "RADIANS".to_string());
        mappings.insert("DEGREES".to_string(), "DEGREES".to_string());

        // Trigonometric functions
        mappings.insert("SIN".to_string(), "SIN".to_string());
        mappings.insert("COS".to_string(), "COS".to_string());
        mappings.insert("TAN".to_string(), "TAN".to_string());
        mappings.insert("ASIN".to_string(), "ASIN".to_string());
        mappings.insert("ACOS".to_string(), "ACOS".to_string());
        mappings.insert("ATAN".to_string(), "ATAN".to_string());
        mappings.insert("ATAN2".to_string(), "ATAN2".to_string());

        // Aggregate functions (mostly compatible)
        mappings.insert("BOOL_AND".to_string(), "MIN".to_string()); // PostgreSQL specific
        mappings.insert("BOOL_OR".to_string(), "MAX".to_string()); // PostgreSQL specific
        mappings.insert("STRING_AGG".to_string(), "STRING_AGG".to_string());
        mappings.insert("ARRAY_AGG".to_string(), "STRING_AGG".to_string()); // Convert array to string

        // Window functions (mostly compatible)
        mappings.insert("ROW_NUMBER".to_string(), "ROW_NUMBER".to_string());
        mappings.insert("RANK".to_string(), "RANK".to_string());
        mappings.insert("DENSE_RANK".to_string(), "DENSE_RANK".to_string());
        mappings.insert("PERCENT_RANK".to_string(), "PERCENT_RANK".to_string());
        mappings.insert("CUME_DIST".to_string(), "CUME_DIST".to_string());
        mappings.insert("NTILE".to_string(), "NTILE".to_string());
        mappings.insert("LAG".to_string(), "LAG".to_string());
        mappings.insert("LEAD".to_string(), "LEAD".to_string());
        mappings.insert("FIRST_VALUE".to_string(), "FIRST_VALUE".to_string());
        mappings.insert("LAST_VALUE".to_string(), "LAST_VALUE".to_string());
        mappings.insert("NTH_VALUE".to_string(), "NTH_VALUE".to_string());

        // JSON functions (PostgreSQL -> HANA approximations)
        mappings.insert(
            "JSON_EXTRACT_PATH_TEXT".to_string(),
            "JSON_VALUE".to_string(),
        );
        mappings.insert("JSON_ARRAY_LENGTH".to_string(), "JSON_QUERY".to_string());

        // System functions
        mappings.insert("VERSION".to_string(), "DATABASE_VERSION".to_string());
        mappings.insert("CURRENT_DATABASE".to_string(), "CURRENT_SCHEMA".to_string());
        mappings.insert("CURRENT_SCHEMA".to_string(), "CURRENT_SCHEMA".to_string());
        mappings.insert("CURRENT_USER".to_string(), "CURRENT_USER".to_string());
        mappings.insert("SESSION_USER".to_string(), "CURRENT_USER".to_string());

        mappings
    }

    /// Get PostgreSQL to HANA operator mappings
    pub fn operator_mappings() -> HashMap<String, String> {
        let mut mappings = HashMap::new();

        // String operators
        mappings.insert("||".to_string(), "||".to_string()); // Concatenation (same)
        mappings.insert("~~".to_string(), "LIKE".to_string()); // LIKE operator
        mappings.insert("~~*".to_string(), "ILIKE".to_string()); // ILIKE operator
        mappings.insert("!~~".to_string(), "NOT LIKE".to_string()); // NOT LIKE
        mappings.insert("!~~*".to_string(), "NOT ILIKE".to_string()); // NOT ILIKE

        // Pattern matching (requires function conversion)
        mappings.insert("~".to_string(), "LOCATE_REGEXPR".to_string()); // Regex match
        mappings.insert("~*".to_string(), "LOCATE_REGEXPR".to_string()); // Case-insensitive regex
        mappings.insert("!~".to_string(), "NOT LOCATE_REGEXPR".to_string()); // Regex not match
        mappings.insert("!~*".to_string(), "NOT LOCATE_REGEXPR".to_string()); // Case-insensitive regex not match

        // Array operators (convert to function calls)
        mappings.insert("@>".to_string(), "JSON_CONTAINS".to_string()); // Contains
        mappings.insert("<@".to_string(), "JSON_CONTAINED".to_string()); // Contained by
        mappings.insert("&&".to_string(), "JSON_OVERLAPS".to_string()); // Overlaps

        // JSON operators
        mappings.insert("->".to_string(), "JSON_VALUE".to_string()); // JSON field access
        mappings.insert("->>".to_string(), "JSON_VALUE".to_string()); // JSON field access as text
        mappings.insert("#>".to_string(), "JSON_QUERY".to_string()); // JSON path access
        mappings.insert("#>>".to_string(), "JSON_VALUE".to_string()); // JSON path access as text

        mappings
    }

    /// Get common PostgreSQL patterns that need transformation
    pub fn common_patterns() -> Vec<(String, String, String)> {
        vec![
            // (name, pattern, replacement)
            (
                "LIMIT_OFFSET".to_string(),
                r"LIMIT\s+(\d+)\s+OFFSET\s+(\d+)".to_string(),
                "LIMIT $2, $1".to_string(),
            ),
            (
                "ILIKE_CASE_INSENSITIVE".to_string(),
                r"(\w+)\s+ILIKE\s+'([^']+)'".to_string(),
                "UPPER($1) LIKE UPPER('$2')".to_string(),
            ),
            (
                "BOOLEAN_TRUE".to_string(),
                r"\btrue\b".to_string(),
                "TRUE".to_string(),
            ),
            (
                "BOOLEAN_FALSE".to_string(),
                r"\bfalse\b".to_string(),
                "FALSE".to_string(),
            ),
            (
                "EXTRACT_DOW".to_string(),
                r"EXTRACT\(dow\s+FROM\s+([^)]+)\)".to_string(),
                "WEEKDAY($1)".to_string(),
            ),
            (
                "EXTRACT_DOY".to_string(),
                r"EXTRACT\(doy\s+FROM\s+([^)]+)\)".to_string(),
                "DAYOFYEAR($1)".to_string(),
            ),
            (
                "EXTRACT_EPOCH".to_string(),
                r"EXTRACT\(epoch\s+FROM\s+([^)]+)\)".to_string(),
                "SECONDS_BETWEEN('1970-01-01 00:00:00', $1)".to_string(),
            ),
        ]
    }

    /// Get PostgreSQL-specific constructs that need manual conversion
    pub fn unsupported_features() -> Vec<String> {
        vec![
            "ARRAY constructors".to_string(),
            "ROW constructors".to_string(),
            "LATERAL joins".to_string(),
            "VALUES as table source".to_string(),
            "INHERITS in CREATE TABLE".to_string(),
            "EXCLUDE constraints".to_string(),
            "Partial indexes".to_string(),
            "Expression indexes".to_string(),
            "LISTEN/NOTIFY".to_string(),
            "Custom data types".to_string(),
            "Domains".to_string(),
            "Extensions".to_string(),
            "PL/pgSQL functions".to_string(),
            "Rules".to_string(),
            "Triggers with complex logic".to_string(),
            "Advisory locks".to_string(),
            "Full text search operators".to_string(),
            "Geometric operators".to_string(),
            "Range operators".to_string(),
            "Network operators".to_string(),
        ]
    }
}
