use pgt::{SqlTransformer, TransformationConfig};

#[cfg(test)]
mod phase3c_rules_engine_tests {
    use super::*;

    fn create_strict_config() -> TransformationConfig {
        let mut config = TransformationConfig::default();
        config.rules.enable_strict_mode = true;
        config.rules.validate_hana_compatibility = true;

        // Enable specific transformation rules
        config
            .rules
            .transformation_rules
            .insert("remove_pg_extensions".to_string(), true);
        config
            .rules
            .transformation_rules
            .insert("validate_identity_columns".to_string(), true);
        config
            .rules
            .transformation_rules
            .insert("check_hana_reserved_words".to_string(), true);
        config
            .rules
            .transformation_rules
            .insert("preserve_comments".to_string(), true);

        config
    }

    #[test]
    fn test_hana_compatibility_validation_multiple_identity() {
        let config = create_strict_config();
        let transformer = SqlTransformer::new(config, pgt::Dialect::Hana).expect("Failed to create transformer");

        // SQL with multiple IDENTITY columns (not allowed in HANA)
        let sql_with_multiple_identity = r#"
            CREATE TABLE test_table (
                id1 INTEGER GENERATED BY DEFAULT AS IDENTITY,
                id2 INTEGER GENERATED BY DEFAULT AS IDENTITY,
                name NVARCHAR(100)
            );
        "#;

        let result = transformer.transform(sql_with_multiple_identity);

        // Should detect HANA compatibility issue
        match result {
            Err(pgt::error::TransformationError::ValidationError {
                hana_rule_violations,
                suggestions,
            }) => {
                assert!(
                    !hana_rule_violations.is_empty(),
                    "Should detect multiple IDENTITY columns"
                );
                assert!(
                    hana_rule_violations
                        .iter()
                        .any(|v| v.contains("IDENTITY") || v.contains("identity")),
                    "Should specifically mention IDENTITY column issue"
                );
                assert!(
                    !suggestions.is_empty(),
                    "Should provide suggestions for fixing the issue"
                );
            }
            _ => {
                // Initial implementation might not have this validation yet
                println!("HANA compatibility validation for multiple IDENTITY columns not yet implemented");
            }
        }
    }

    #[test]
    fn test_postgresql_extension_removal() {
        let config = create_strict_config();
        let transformer = SqlTransformer::new(config, pgt::Dialect::Hana).expect("Failed to create transformer");

        // SQL with PostgreSQL extensions
        let sql_with_extensions = r#"
            CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
            CREATE EXTENSION IF NOT EXISTS "postgis";

            CREATE TABLE test_table (
                id UUID DEFAULT uuid_generate_v4(),
                name NVARCHAR(100)
            );
        "#;

        let result = transformer.transform(sql_with_extensions);

        match result {
            Ok(transformed) => {
                // Extensions should be removed or commented out
                assert!(
                    !transformed.contains("CREATE EXTENSION")
                        || transformed.contains("-- CREATE EXTENSION"),
                    "Extensions should be removed or commented"
                );

                // Functions from extensions should be handled
                if transformed.contains("uuid_generate_v4") {
                    println!("Note: Extension function transformation not yet implemented");
                }
            }
            Err(e) => {
                // Should provide specific guidance about extension handling
                println!("Extension handling error (expected): {:?}", e);
            }
        }
    }

    #[test]
    fn test_hana_reserved_word_detection() {
        let config = create_strict_config();
        let transformer = SqlTransformer::new(config, pgt::Dialect::Hana).expect("Failed to create transformer");

        // SQL using HANA reserved words as identifiers
        let sql_with_reserved_words = r#"
            CREATE TABLE test_table (
                "OBJECT" NVARCHAR(100),  -- OBJECT is reserved in HANA
                "SYSTEM" INTEGER,        -- SYSTEM is reserved in HANA
                "VIEW" NVARCHAR(50),     -- VIEW is reserved in HANA
                normal_column NVARCHAR(100)
            );
        "#;

        let result = transformer.transform(sql_with_reserved_words);

        match result {
            Ok(transformed) => {
                // Reserved words should be properly quoted or renamed
                assert!(
                    transformed.contains("\"OBJECT\"") || transformed.contains("OBJECT_COL"),
                    "Reserved words should be handled"
                );
                println!("Transformed SQL with reserved words: {}", transformed);
            }
            Err(pgt::error::TransformationError::ValidationError {
                hana_rule_violations,
                suggestions,
            }) => {
                // Should detect reserved word usage
                assert!(
                    hana_rule_violations.iter().any(|v| v.contains("reserved")
                        || v.contains("OBJECT")
                        || v.contains("SYSTEM")),
                    "Should detect HANA reserved word usage"
                );
                assert!(
                    !suggestions.is_empty(),
                    "Should suggest alternatives for reserved words"
                );
            }
            _ => {
                println!("Reserved word detection not yet implemented");
            }
        }
    }

    #[test]
    fn test_complex_transformation_rules() {
        let mut config = create_strict_config();

        // Configure specific transformation behaviors
        config
            .rules
            .transformation_rules
            .insert("convert_arrays_to_json".to_string(), true);
        config
            .rules
            .transformation_rules
            .insert("handle_inheritance".to_string(), false);
        config
            .rules
            .transformation_rules
            .insert("preserve_pg_syntax".to_string(), false);

        let transformer = SqlTransformer::new(config.clone(), pgt::Dialect::Hana).expect("Failed to create transformer");

        // Complex SQL with various PostgreSQL features
        let complex_sql = r#"
            CREATE TABLE parent_table (
                id SERIAL PRIMARY KEY,
                data JSONB,
                tags TEXT[],
                metadata HSTORE
            );

            CREATE TABLE child_table () INHERITS (parent_table);

            INSERT INTO parent_table (data, tags) VALUES
                ('{"key": "value"}'::JSONB, ARRAY['tag1', 'tag2']::TEXT[]);
        "#;

        let result = transformer.transform(complex_sql);

        match result {
            Ok(transformed) => {
                // Arrays should be converted based on rules
                if config.rules.transformation_rules["convert_arrays_to_json"] {
                    assert!(
                        transformed.contains("NCLOB") || transformed.contains("JSON"),
                        "Arrays should be converted to JSON when rule is enabled"
                    );
                }

                // SERIAL should be transformed
                assert!(
                    transformed.contains("GENERATED BY DEFAULT AS IDENTITY"),
                    "SERIAL should be transformed to IDENTITY"
                );

                // Inheritance should be handled (removed or error)
                assert!(
                    !transformed.contains("INHERITS") || transformed.contains("-- INHERITS"),
                    "Table inheritance should be handled"
                );

                println!("Complex transformation result: {}", transformed);
            }
            Err(e) => {
                // Should provide detailed information about unsupported features
                println!("Complex transformation error (may be expected): {:?}", e);
            }
        }
    }

    #[test]
    fn test_rule_engine_performance() {
        let config = create_strict_config();
        let transformer = SqlTransformer::new(config, pgt::Dialect::Hana).expect("Failed to create transformer");

        // Large SQL with many statements to test rule engine performance
        let mut large_sql = String::new();
        for i in 0..100 {
            large_sql.push_str(&format!(
                r#"
                CREATE TABLE table_{} (
                    id SERIAL PRIMARY KEY,
                    name VARCHAR(100),
                    data TEXT,
                    created_at TIMESTAMPTZ DEFAULT NOW()
                );

                INSERT INTO table_{} (name, data) VALUES ('test{}', 'data{}');
            "#,
                i, i, i, i
            ));
        }

        let start_time = std::time::Instant::now();
        let result = transformer.transform(&large_sql);
        let duration = start_time.elapsed();

        println!("Rule engine processing time for 100 tables: {:?}", duration);
        assert!(
            duration.as_secs() < 5,
            "Rule engine should process 100 tables in under 5 seconds"
        );

        match result {
            Ok(transformed) => {
                // Verify that all transformations were applied
                assert!(
                    transformed.contains("GENERATED BY DEFAULT AS IDENTITY"),
                    "All SERIAL columns should be transformed"
                );
                assert!(
                    transformed.contains("CURRENT_TIMESTAMP"),
                    "All NOW() functions should be transformed"
                );

                // Count transformations
                let identity_count = transformed
                    .matches("GENERATED BY DEFAULT AS IDENTITY")
                    .count();
                assert_eq!(
                    identity_count, 100,
                    "Should have 100 IDENTITY transformations"
                );
            }
            Err(e) => {
                println!("Large SQL transformation error: {:?}", e);
                // Even if it fails, should provide useful error information
            }
        }
    }

    #[test]
    fn test_rule_conflicts_and_resolution() {
        let mut config = TransformationConfig::default();
        config.rules.enable_strict_mode = true;

        // Set conflicting rules
        config
            .rules
            .transformation_rules
            .insert("preserve_pg_syntax".to_string(), true);
        config
            .rules
            .transformation_rules
            .insert("force_hana_compatibility".to_string(), true);
        config
            .rules
            .transformation_rules
            .insert("convert_all_types".to_string(), false);
        config
            .rules
            .transformation_rules
            .insert("preserve_original_types".to_string(), true);

        // Configuration validation should detect conflicts
        let validation_result = config.validate();

        // For now, basic validation might not catch rule conflicts
        // But the transformer should handle conflicting rules gracefully
        let transformer = SqlTransformer::new(config, pgt::Dialect::Hana).expect("Failed to create transformer");

        let sql = r#"
            CREATE TABLE test_table (
                id SERIAL,
                data VARCHAR(100)
            );
        "#;

        let result = transformer.transform(sql);

        // Should either resolve conflicts or provide clear error about conflicting rules
        match result {
            Ok(transformed) => {
                println!("Conflicting rules resolved to: {}", transformed);
                // Should have applied some consistent set of transformations
                assert!(!transformed.is_empty(), "Should produce some output");
            }
            Err(e) => {
                println!("Rule conflict error: {:?}", e);
                // Should provide clear information about rule conflicts
            }
        }
    }
}
