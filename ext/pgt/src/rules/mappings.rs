use std::collections::HashMap;

pub struct StaticMappings;

impl StaticMappings {
    pub fn data_type_mappings() -> HashMap<String, String> {
        let mut mappings = HashMap::new();

        mappings.insert(
            "SERIAL".to_string(),
            "INTEGER GENERATED BY DEFAULT AS IDENTITY".to_string(),
        );
        mappings.insert(
            "BIGSERIAL".to_string(),
            "BIGINT GENERATED BY DEFAULT AS IDENTITY".to_string(),
        );
        mappings.insert(
            "SMALLSERIAL".to_string(),
            "SMALLINT GENERATED BY DEFAULT AS IDENTITY".to_string(),
        );

        mappings.insert("TEXT".to_string(), "NCLOB".to_string());
        mappings.insert("VARCHAR".to_string(), "NVARCHAR".to_string());
        mappings.insert("CHAR".to_string(), "NCHAR".to_string());
        mappings.insert("CHARACTER".to_string(), "NCHAR".to_string());
        mappings.insert("CHARACTER VARYING".to_string(), "NVARCHAR".to_string());

        mappings.insert("JSON".to_string(), "NCLOB".to_string());
        mappings.insert("JSONB".to_string(), "NCLOB".to_string());

        mappings.insert("UUID".to_string(), "NVARCHAR(36)".to_string());
        mappings.insert("INET".to_string(), "NVARCHAR(45)".to_string());
        mappings.insert("CIDR".to_string(), "NVARCHAR(45)".to_string());
        mappings.insert("MACADDR".to_string(), "NVARCHAR(17)".to_string());
        mappings.insert("MACADDR8".to_string(), "NVARCHAR(23)".to_string());

        mappings.insert("BYTEA".to_string(), "BLOB".to_string());

        mappings.insert("TIMESTAMPTZ".to_string(), "TIMESTAMP".to_string());
        mappings.insert(
            "TIMESTAMP WITH TIME ZONE".to_string(),
            "TIMESTAMP".to_string(),
        );
        mappings.insert("TIMETZ".to_string(), "TIME".to_string());
        mappings.insert("TIME WITH TIME ZONE".to_string(), "TIME".to_string());

        mappings.insert("POINT".to_string(), "NVARCHAR(50)".to_string());
        mappings.insert("LINE".to_string(), "NVARCHAR(100)".to_string());
        mappings.insert("LSEG".to_string(), "NVARCHAR(100)".to_string());
        mappings.insert("BOX".to_string(), "NVARCHAR(100)".to_string());
        mappings.insert("PATH".to_string(), "NCLOB".to_string());
        mappings.insert("POLYGON".to_string(), "NCLOB".to_string());
        mappings.insert("CIRCLE".to_string(), "NVARCHAR(100)".to_string());

        mappings.insert("INTEGER[]".to_string(), "NCLOB".to_string());
        mappings.insert("TEXT[]".to_string(), "NCLOB".to_string());
        mappings.insert("VARCHAR[]".to_string(), "NCLOB".to_string());

        mappings.insert("INT4RANGE".to_string(), "NVARCHAR(50)".to_string());
        mappings.insert("INT8RANGE".to_string(), "NVARCHAR(50)".to_string());
        mappings.insert("NUMRANGE".to_string(), "NVARCHAR(100)".to_string());
        mappings.insert("TSRANGE".to_string(), "NVARCHAR(100)".to_string());
        mappings.insert("TSTZRANGE".to_string(), "NVARCHAR(100)".to_string());
        mappings.insert("DATERANGE".to_string(), "NVARCHAR(50)".to_string());

        mappings
    }

    pub fn function_mappings() -> HashMap<String, String> {
        let mut mappings = HashMap::new();

        // NOW() is natively supported in HANA
        mappings.insert(
            "CURRENT_TIMESTAMP()".to_string(),
            "CURRENT_TIMESTAMP".to_string(),
        );
        mappings.insert("CURRENT_TIME()".to_string(), "CURRENT_TIME".to_string());
        mappings.insert("CURRENT_DATE()".to_string(), "CURRENT_DATE".to_string());
        mappings.insert(
            "LOCALTIMESTAMP".to_string(),
            "CURRENT_TIMESTAMP".to_string(),
        );
        mappings.insert("LOCALTIME".to_string(), "CURRENT_TIME".to_string());

        mappings.insert("RANDOM".to_string(), "RAND".to_string());
        mappings.insert("POSITION".to_string(), "LOCATE".to_string());
        mappings.insert("STRPOS".to_string(), "LOCATE".to_string());
        mappings.insert("CHR".to_string(), "CHAR".to_string());
        mappings.insert("ASCII".to_string(), "ASCII".to_string());
        mappings.insert("MD5".to_string(), "HASH_MD5".to_string());

        mappings.insert("POWER".to_string(), "POWER".to_string());
        mappings.insert("POW".to_string(), "POWER".to_string());
        mappings.insert("SQRT".to_string(), "SQRT".to_string());
        // HANA lacks CBRT; approximate via POWER
        mappings.insert("CBRT".to_string(), "POWER(?, 1.0/3.0)".to_string());
        mappings.insert("EXP".to_string(), "EXP".to_string());
        mappings.insert("LN".to_string(), "LN".to_string());
        mappings.insert("LOG".to_string(), "LOG".to_string());
        mappings.insert("LOG10".to_string(), "LOG".to_string());
        mappings.insert("PI".to_string(), "PI".to_string());
        mappings.insert("RADIANS".to_string(), "RADIANS".to_string());
        mappings.insert("DEGREES".to_string(), "DEGREES".to_string());

        mappings.insert("SIN".to_string(), "SIN".to_string());
        mappings.insert("COS".to_string(), "COS".to_string());
        mappings.insert("TAN".to_string(), "TAN".to_string());
        mappings.insert("ASIN".to_string(), "ASIN".to_string());
        mappings.insert("ACOS".to_string(), "ACOS".to_string());
        mappings.insert("ATAN".to_string(), "ATAN".to_string());
        mappings.insert("ATAN2".to_string(), "ATAN2".to_string());

        // BOOL_AND/BOOL_OR have no HANA equivalent; MIN/MAX on booleans approximate the behavior
        mappings.insert("BOOL_AND".to_string(), "MIN".to_string());
        mappings.insert("BOOL_OR".to_string(), "MAX".to_string());
        mappings.insert("STRING_AGG".to_string(), "STRING_AGG".to_string());
        // HANA lacks ARRAY_AGG; STRING_AGG is a lossy approximation
        mappings.insert("ARRAY_AGG".to_string(), "STRING_AGG".to_string());

        mappings.insert("ROW_NUMBER".to_string(), "ROW_NUMBER".to_string());
        mappings.insert("RANK".to_string(), "RANK".to_string());
        mappings.insert("DENSE_RANK".to_string(), "DENSE_RANK".to_string());
        mappings.insert("PERCENT_RANK".to_string(), "PERCENT_RANK".to_string());
        mappings.insert("CUME_DIST".to_string(), "CUME_DIST".to_string());
        mappings.insert("NTILE".to_string(), "NTILE".to_string());
        mappings.insert("LAG".to_string(), "LAG".to_string());
        mappings.insert("LEAD".to_string(), "LEAD".to_string());
        mappings.insert("FIRST_VALUE".to_string(), "FIRST_VALUE".to_string());
        mappings.insert("LAST_VALUE".to_string(), "LAST_VALUE".to_string());
        mappings.insert("NTH_VALUE".to_string(), "NTH_VALUE".to_string());

        mappings.insert(
            "JSON_EXTRACT_PATH_TEXT".to_string(),
            "JSON_VALUE".to_string(),
        );
        mappings.insert("JSON_ARRAY_LENGTH".to_string(), "JSON_QUERY".to_string());

        mappings.insert("VERSION".to_string(), "DATABASE_VERSION".to_string());
        mappings.insert("CURRENT_DATABASE".to_string(), "CURRENT_SCHEMA".to_string());
        mappings.insert("CURRENT_SCHEMA".to_string(), "CURRENT_SCHEMA".to_string());
        mappings.insert("CURRENT_USER".to_string(), "CURRENT_USER".to_string());
        mappings.insert("SESSION_USER".to_string(), "CURRENT_USER".to_string());

        mappings
    }

    pub fn operator_mappings() -> HashMap<String, String> {
        let mut mappings = HashMap::new();

        mappings.insert("||".to_string(), "||".to_string());
        mappings.insert("~~".to_string(), "LIKE".to_string());
        mappings.insert("~~*".to_string(), "ILIKE".to_string());
        mappings.insert("!~~".to_string(), "NOT LIKE".to_string());
        mappings.insert("!~~*".to_string(), "NOT ILIKE".to_string());

        // PostgreSQL regex operators map to HANA LOCATE_REGEXPR
        mappings.insert("~".to_string(), "LOCATE_REGEXPR".to_string());
        mappings.insert("~*".to_string(), "LOCATE_REGEXPR".to_string());
        mappings.insert("!~".to_string(), "NOT LOCATE_REGEXPR".to_string());
        mappings.insert("!~*".to_string(), "NOT LOCATE_REGEXPR".to_string());

        // PostgreSQL array/JSON operators map to HANA JSON functions
        mappings.insert("@>".to_string(), "JSON_CONTAINS".to_string());
        mappings.insert("<@".to_string(), "JSON_CONTAINED".to_string());
        mappings.insert("&&".to_string(), "JSON_OVERLAPS".to_string());

        mappings.insert("->".to_string(), "JSON_VALUE".to_string());
        mappings.insert("->>".to_string(), "JSON_VALUE".to_string());
        mappings.insert("#>".to_string(), "JSON_QUERY".to_string());
        mappings.insert("#>>".to_string(), "JSON_VALUE".to_string());

        mappings
    }

    pub fn common_patterns() -> Vec<(String, String, String)> {
        vec![
            (
                "LIMIT_OFFSET".to_string(),
                r"LIMIT\s+(\d+)\s+OFFSET\s+(\d+)".to_string(),
                "LIMIT $2, $1".to_string(),
            ),
            (
                "ILIKE_CASE_INSENSITIVE".to_string(),
                r"(\w+)\s+ILIKE\s+'([^']+)'".to_string(),
                "UPPER($1) LIKE UPPER('$2')".to_string(),
            ),
            (
                "BOOLEAN_TRUE".to_string(),
                r"\btrue\b".to_string(),
                "TRUE".to_string(),
            ),
            (
                "BOOLEAN_FALSE".to_string(),
                r"\bfalse\b".to_string(),
                "FALSE".to_string(),
            ),
            (
                "EXTRACT_DOW".to_string(),
                r"EXTRACT\(dow\s+FROM\s+([^)]+)\)".to_string(),
                "WEEKDAY($1)".to_string(),
            ),
            (
                "EXTRACT_DOY".to_string(),
                r"EXTRACT\(doy\s+FROM\s+([^)]+)\)".to_string(),
                "DAYOFYEAR($1)".to_string(),
            ),
            (
                "EXTRACT_EPOCH".to_string(),
                r"EXTRACT\(epoch\s+FROM\s+([^)]+)\)".to_string(),
                "SECONDS_BETWEEN('1970-01-01 00:00:00', $1)".to_string(),
            ),
        ]
    }

    pub fn unsupported_features() -> Vec<String> {
        vec![
            "ARRAY constructors".to_string(),
            "ROW constructors".to_string(),
            "LATERAL joins".to_string(),
            "VALUES as table source".to_string(),
            "INHERITS in CREATE TABLE".to_string(),
            "EXCLUDE constraints".to_string(),
            "Partial indexes".to_string(),
            "Expression indexes".to_string(),
            "LISTEN/NOTIFY".to_string(),
            "Custom data types".to_string(),
            "Domains".to_string(),
            "Extensions".to_string(),
            "PL/pgSQL functions".to_string(),
            "Rules".to_string(),
            "Triggers with complex logic".to_string(),
            "Advisory locks".to_string(),
            "Full text search operators".to_string(),
            "Geometric operators".to_string(),
            "Range operators".to_string(),
            "Network operators".to_string(),
        ]
    }
}
