use crate::error::{TransformationError, TransformationResult};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs;
use std::path::Path;

/// Main configuration for SQL transformation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TransformationConfig {
    pub data_types: DataTypeConfig,
    pub functions: FunctionConfig,
    pub schema_handling: SchemaConfig,
    pub optimization: OptimizationConfig,
    pub formatting: FormattingConfig,
    pub rules: RulesConfig,
}

impl Default for TransformationConfig {
    fn default() -> Self {
        Self {
            data_types: DataTypeConfig::default(),
            functions: FunctionConfig::default(),
            schema_handling: SchemaConfig::default(),
            optimization: OptimizationConfig::default(),
            formatting: FormattingConfig::default(),
            rules: RulesConfig::default(),
        }
    }
}

/// Configuration for data type transformations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DataTypeConfig {
    pub preserve_precision: bool,
    pub custom_mappings: HashMap<String, String>,
    pub handle_arrays: ArrayHandlingStrategy,
}

impl Default for DataTypeConfig {
    fn default() -> Self {
        Self {
            preserve_precision: true,
            custom_mappings: HashMap::new(),
            handle_arrays: ArrayHandlingStrategy::AsJson,
        }
    }
}

/// Strategy for handling PostgreSQL arrays in HANA
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ArrayHandlingStrategy {
    AsJson,
    AsDelimitedString,
    AsMultipleColumns,
    Error,
}

/// Configuration for function transformations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FunctionConfig {
    pub preserve_case: bool,
    pub enable_custom_functions: bool,
    pub custom_mappings: HashMap<String, String>,
}

impl Default for FunctionConfig {
    fn default() -> Self {
        Self {
            preserve_case: false,
            enable_custom_functions: true,
            custom_mappings: HashMap::new(),
        }
    }
}

/// Configuration for schema and identifier handling
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SchemaConfig {
    pub default_schema: String,
    pub preserve_schema_names: bool,
    pub schema_mappings: HashMap<String, String>,
}

impl Default for SchemaConfig {
    fn default() -> Self {
        Self {
            default_schema: "PUBLIC".to_string(),
            preserve_schema_names: true,
            schema_mappings: HashMap::new(),
        }
    }
}

/// Configuration for HANA-specific optimizations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OptimizationConfig {
    pub use_column_store_hints: bool,
    pub enable_parallel_execution: bool,
    pub suggest_indexes: bool,
}

impl Default for OptimizationConfig {
    fn default() -> Self {
        Self {
            use_column_store_hints: true,
            enable_parallel_execution: true,
            suggest_indexes: false,
        }
    }
}

/// Configuration for SQL formatting
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FormattingConfig {
    pub indent_size: usize,
    pub max_line_length: usize,
    pub capitalize_keywords: bool,
    pub preserve_comments: bool,
}

impl Default for FormattingConfig {
    fn default() -> Self {
        Self {
            indent_size: 2,
            max_line_length: 120,
            capitalize_keywords: true,
            preserve_comments: true,
        }
    }
}

impl TransformationConfig {
    /// Save configuration to a TOML file
    pub fn to_file(&self, path: &std::path::Path) -> anyhow::Result<()> {
        let content = toml::to_string_pretty(self)?;
        std::fs::write(path, content)?;
        Ok(())
    }

    /// Get the default data type mapping
    pub fn get_default_data_type_mappings() -> HashMap<String, String> {
        let mut mappings = HashMap::new();

        // Basic type mappings
        mappings.insert(
            "SERIAL".to_string(),
            "INTEGER GENERATED BY DEFAULT AS IDENTITY".to_string(),
        );
        mappings.insert(
            "BIGSERIAL".to_string(),
            "BIGINT GENERATED BY DEFAULT AS IDENTITY".to_string(),
        );
        mappings.insert("TEXT".to_string(), "NCLOB".to_string());
        mappings.insert("VARCHAR".to_string(), "NVARCHAR".to_string());
        mappings.insert("CHAR".to_string(), "NCHAR".to_string());
        mappings.insert("TIMESTAMPTZ".to_string(), "TIMESTAMP".to_string());
        mappings.insert("JSON".to_string(), "NCLOB".to_string());
        mappings.insert("JSONB".to_string(), "NCLOB".to_string());
        mappings.insert("UUID".to_string(), "NVARCHAR(36)".to_string());
        mappings.insert("INET".to_string(), "NVARCHAR(45)".to_string());
        mappings.insert("MACADDR".to_string(), "NVARCHAR(17)".to_string());

        mappings
    }

    /// Get the default function mapping
    pub fn get_default_function_mappings() -> HashMap<String, String> {
        let mut mappings = HashMap::new();

        // Simple function name mappings
        mappings.insert("RANDOM".to_string(), "RAND".to_string());
        // NOW() is supported natively in HANA, no transformation needed
        mappings.insert(
            "CURRENT_TIMESTAMP()".to_string(),
            "CURRENT_TIMESTAMP".to_string(),
        );

        mappings
    }
}

impl TransformationConfig {
    /// Load configuration from a TOML file
    pub fn from_file<P: AsRef<Path>>(path: P) -> TransformationResult<Self> {
        let content = fs::read_to_string(path).map_err(|e| TransformationError::ConfigError {
            message: format!("Failed to read config file: {}", e),
        })?;

        let config: Self =
            toml::from_str(&content).map_err(|e| TransformationError::ConfigError {
                message: format!("Failed to parse config file: {}", e),
            })?;

        config.validate()?;
        Ok(config)
    }

    /// Load configuration from environment variables
    pub fn from_env() -> Self {
        let mut config = Self::default();

        if let Ok(val) = std::env::var("PGT_PRESERVE_PRECISION") {
            config.data_types.preserve_precision = val.parse().unwrap_or(true);
        }

        if let Ok(val) = std::env::var("PGT_PRESERVE_CASE") {
            config.functions.preserve_case = val.parse().unwrap_or(false);
        }

        if let Ok(val) = std::env::var("PGT_STRICT_MODE") {
            config.rules.enable_strict_mode = val.parse().unwrap_or(false);
        }

        if let Ok(val) = std::env::var("PGT_VALIDATE_COMPATIBILITY") {
            config.rules.validate_hana_compatibility = val.parse().unwrap_or(true);
        }

        config
    }

    pub fn merge(configs: Vec<Self>) -> TransformationResult<Self> {
        let mut result = Self::default();

        for config in configs {
            result.data_types.preserve_precision = config.data_types.preserve_precision;
            result.data_types.handle_arrays = config.data_types.handle_arrays;
            result
                .data_types
                .custom_mappings
                .extend(config.data_types.custom_mappings);

            result.functions.preserve_case = config.functions.preserve_case;
            result
                .functions
                .custom_mappings
                .extend(config.functions.custom_mappings);

            result.schema_handling = config.schema_handling;
            result.optimization = config.optimization;
            result.formatting = config.formatting;

            result.rules.enable_strict_mode = config.rules.enable_strict_mode;
            result.rules.validate_hana_compatibility = config.rules.validate_hana_compatibility;
            result
                .rules
                .transformation_rules
                .extend(config.rules.transformation_rules);
        }

        result.validate()?;
        Ok(result)
    }

    /// Validate configuration for consistency and completeness
    pub fn validate(&self) -> TransformationResult<()> {
        let mut errors = Vec::new();

        // Validate data type mappings
        for (key, value) in &self.data_types.custom_mappings {
            if key.is_empty() {
                errors.push("Data type mapping cannot have empty key".to_string());
            }
            if value.is_empty() {
                errors.push(format!(
                    "Data type mapping for '{}' cannot have empty value",
                    key
                ));
            }
        }

        // Validate function mappings
        for (key, value) in &self.functions.custom_mappings {
            if key.is_empty() {
                errors.push("Function mapping cannot have empty key".to_string());
            }
            if value.is_empty() {
                errors.push(format!(
                    "Function mapping for '{}' cannot have empty value",
                    key
                ));
            }
        }

        if errors.is_empty() {
            Ok(())
        } else {
            Err(TransformationError::ConfigError {
                message: errors.join("; "),
            })
        }
    }

    /// Apply default mappings if custom mappings are empty
    pub fn apply_defaults(&mut self) {
        if self.data_types.custom_mappings.is_empty() {
            self.data_types.custom_mappings = Self::get_default_data_type_mappings();
        }

        if self.functions.custom_mappings.is_empty() {
            self.functions.custom_mappings = Self::get_default_function_mappings();
        }
    }
}

/// Configuration for transformation rules and validation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RulesConfig {
    pub enable_strict_mode: bool,
    pub validate_hana_compatibility: bool,
    pub transformation_rules: HashMap<String, bool>,
}

impl Default for RulesConfig {
    fn default() -> Self {
        Self {
            enable_strict_mode: false,
            validate_hana_compatibility: true,
            transformation_rules: HashMap::new(),
        }
    }
}
