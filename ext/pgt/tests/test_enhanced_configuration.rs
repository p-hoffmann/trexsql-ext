use pgt::{SqlTransformer, TransformationConfig};
use std::fs;
use tempfile::tempdir;

#[cfg(test)]
mod phase3c_configuration_tests {
    use super::*;

    #[test]
    fn test_custom_mapping_file_loading() {
        let temp_dir = tempdir().expect("Failed to create temp directory");
        let config_file = temp_dir.path().join("custom_mappings.toml");

        // Create a custom mapping configuration file
        let config_content = r#"
[data_types]
preserve_precision = true
handle_arrays = "AsJson"

[data_types.custom_mappings]
"CUSTOM_TYPE" = "NVARCHAR(1000)"
"SPECIAL_NUMERIC" = "DECIMAL(18,2)"
"LARGE_TEXT" = "NCLOB"

[functions]
preserve_case = false
enable_custom_functions = true

[functions.custom_mappings]
"CUSTOM_FUNC" = "HANA_EQUIVALENT_FUNC"
"SPECIAL_CALC" = "CUSTOM_CALCULATION"

[schema_handling]
default_schema = "PUBLIC"
preserve_schema_names = true

[schema_handling.schema_mappings]

[optimization]
use_column_store_hints = true
enable_parallel_execution = true
suggest_indexes = false

[formatting]
indent_size = 2
max_line_length = 120
capitalize_keywords = true
preserve_comments = true

[rules]
enable_strict_mode = true
validate_hana_compatibility = true

[rules.transformation_rules]
"remove_pg_extensions" = true
"convert_arrays_to_json" = false
        "#;

        fs::write(&config_file, config_content).expect("Failed to write config file");

        // Test loading configuration from file
        let config = TransformationConfig::from_file(&config_file).expect("Failed to load config");

        // Verify data type mappings
        assert_eq!(
            config.data_types.custom_mappings.get("CUSTOM_TYPE"),
            Some(&"NVARCHAR(1000)".to_string())
        );
        assert_eq!(
            config.data_types.custom_mappings.get("SPECIAL_NUMERIC"),
            Some(&"DECIMAL(18,2)".to_string())
        );
        assert_eq!(
            config.data_types.custom_mappings.get("LARGE_TEXT"),
            Some(&"NCLOB".to_string())
        );
        assert!(config.data_types.preserve_precision);

        // Verify function mappings
        assert_eq!(
            config.functions.custom_mappings.get("CUSTOM_FUNC"),
            Some(&"HANA_EQUIVALENT_FUNC".to_string())
        );
        assert_eq!(
            config.functions.custom_mappings.get("SPECIAL_CALC"),
            Some(&"CUSTOM_CALCULATION".to_string())
        );
        assert!(!config.functions.preserve_case);

        // Verify rules configuration
        assert!(config.rules.enable_strict_mode);
        assert!(config.rules.validate_hana_compatibility);
        assert_eq!(
            config
                .rules
                .transformation_rules
                .get("remove_pg_extensions"),
            Some(&true)
        );
        assert_eq!(
            config
                .rules
                .transformation_rules
                .get("convert_arrays_to_json"),
            Some(&false)
        );
    }

    #[test]
    fn test_transformation_rules_application() {
        let mut config = TransformationConfig::default();

        // Configure specific transformation rules
        config.rules.enable_strict_mode = true;
        config.rules.validate_hana_compatibility = true;
        config
            .rules
            .transformation_rules
            .insert("strict_data_types".to_string(), true);
        config
            .rules
            .transformation_rules
            .insert("preserve_comments".to_string(), true);

        let transformer = SqlTransformer::new(config, pgt::Dialect::Hana).expect("Failed to create transformer");

        // Test SQL with PostgreSQL-specific features that should be handled by rules
        let sql_with_pg_features = r#"
            -- PostgreSQL comment style
            CREATE TABLE test_table (
                id SERIAL PRIMARY KEY,
                data JSONB,
                tags TEXT[],
                created_at TIMESTAMPTZ DEFAULT NOW()
            );

            /* Multi-line comment */
            CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
        "#;

        let result = transformer.transform(sql_with_pg_features);

        match result {
            Ok(transformed) => {
                // Verify that rules were applied
                assert!(
                    transformed.contains("GENERATED BY DEFAULT AS IDENTITY"),
                    "SERIAL should be transformed"
                );
                assert!(
                    transformed.contains("NCLOB"),
                    "JSONB should be handled by rules"
                );
                assert!(
                    transformed.contains("CURRENT_TIMESTAMP"),
                    "NOW() should be transformed"
                );

                // Comments should be preserved if rule is enabled
                assert!(
                    transformed.contains("--") || transformed.contains("/*"),
                    "Comments should be preserved"
                );

                // Extensions should be handled (removed or transformed)
                assert!(
                    !transformed.contains("CREATE EXTENSION")
                        || transformed.contains("-- Extension"),
                    "Extensions should be handled by rules"
                );
            }
            Err(e) => {
                // If strict mode causes failure, should get detailed error
                println!(
                    "Strict mode validation error (expected in some cases): {:?}",
                    e
                );
            }
        }
    }

    #[test]
    fn test_configuration_validation() {
        // Test invalid configuration detection
        let mut invalid_config = TransformationConfig::default();

        // Add conflicting or invalid settings
        invalid_config
            .data_types
            .custom_mappings
            .insert("".to_string(), "NVARCHAR(100)".to_string()); // Empty key
        invalid_config
            .data_types
            .custom_mappings
            .insert("VALID_TYPE".to_string(), "".to_string()); // Empty value

        // Configuration validation should catch these issues
        let validation_result = invalid_config.validate();

        assert!(
            validation_result.is_err(),
            "Should detect invalid configuration"
        );

        if let Err(error) = validation_result {
            let error_message = error.to_string();
            assert!(
                error_message.contains("empty")
                    || error_message.contains("invalid")
                    || error_message.contains("data_types"),
                "Should identify specific validation issues: {}",
                error_message
            );
        }
    }

    #[test]
    fn test_environment_based_configuration() {
        // Test loading configuration from environment variables
        std::env::set_var("PGT_PRESERVE_PRECISION", "true");
        std::env::set_var("PGT_STRICT_MODE", "false");
        std::env::set_var("PGT_VALIDATE_COMPATIBILITY", "true");

        let config = TransformationConfig::from_env();

        assert!(config.data_types.preserve_precision);
        assert!(!config.rules.enable_strict_mode);
        assert!(config.rules.validate_hana_compatibility);

        // Clean up environment variables
        std::env::remove_var("PGT_PRESERVE_PRECISION");
        std::env::remove_var("PGT_STRICT_MODE");
        std::env::remove_var("PGT_VALIDATE_COMPATIBILITY");
    }

    #[test]
    fn test_configuration_merging() {
        // Test merging multiple configuration sources
        let base_config = TransformationConfig::default();

        let mut file_config = TransformationConfig::default();
        file_config.data_types.preserve_precision = true;
        file_config
            .data_types
            .custom_mappings
            .insert("FILE_TYPE".to_string(), "NVARCHAR(500)".to_string());

        let mut env_config = TransformationConfig::default();
        env_config.rules.enable_strict_mode = true;
        env_config
            .data_types
            .custom_mappings
            .insert("ENV_TYPE".to_string(), "DECIMAL(10,2)".to_string());

        // Merge configurations (env should override file, file should override base)
        let merged_config = TransformationConfig::merge(vec![base_config, file_config, env_config])
            .expect("Failed to merge configurations");

        // Verify merged values
        assert!(merged_config.data_types.preserve_precision); // From file
        assert!(merged_config.rules.enable_strict_mode); // From env
        assert!(merged_config
            .data_types
            .custom_mappings
            .contains_key("FILE_TYPE")); // From file
        assert!(merged_config
            .data_types
            .custom_mappings
            .contains_key("ENV_TYPE")); // From env
    }

    #[test]
    fn test_rule_based_transformation_behavior() {
        // Test different rule configurations produce different transformation behavior
        let base_sql = r#"
            CREATE TABLE test_table (
                id SERIAL,
                data TEXT,
                created_at TIMESTAMP WITH TIME ZONE
            );
        "#;

        // Lenient mode configuration
        let mut lenient_config = TransformationConfig::default();
        lenient_config.rules.enable_strict_mode = false;
        lenient_config.rules.validate_hana_compatibility = false;

        let lenient_transformer = SqlTransformer::new(lenient_config, pgt::Dialect::Hana)
            .expect("Failed to create transformer");
        let lenient_result = lenient_transformer.transform(base_sql);

        // Strict mode configuration
        let mut strict_config = TransformationConfig::default();
        strict_config.rules.enable_strict_mode = true;
        strict_config.rules.validate_hana_compatibility = true;

        let strict_transformer = SqlTransformer::new(strict_config, pgt::Dialect::Hana)
            .expect("Failed to create transformer");
        let strict_result = strict_transformer.transform(base_sql);

        // Both should succeed but with different levels of validation
        assert!(lenient_result.is_ok(), "Lenient mode should succeed");

        // Strict mode might succeed with warnings or fail with detailed validation
        match strict_result {
            Ok(sql) => {
                println!("Strict mode succeeded with: {}", sql);
                // Should have applied more thorough transformations
            }
            Err(e) => {
                println!("Strict mode validation caught issues: {:?}", e);
                // Should provide detailed feedback about HANA compatibility
            }
        }
    }
}
